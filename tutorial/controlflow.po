# Python Documentation Turkish Translation
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-01 00:21+0000\n"
"PO-Revision-Date: 2022-12-28 21:35+0300\n"
"Last-Translator: \n"
"Language-Team: TURKISH <python.docs.tr@gmail.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.2.2\n"

#: tutorial/controlflow.rst:5
msgid "More Control Flow Tools"
msgstr "Daha Fazla Kontrol Akışı Aracı"

#: tutorial/controlflow.rst:7
#, fuzzy
msgid ""
"As well as the :keyword:`while` statement just introduced, Python uses a few "
"more that we will encounter in this chapter."
msgstr ""
"Az önce tanıtılan :keyword:`while` deyiminin yanı sıra Python, bazı "
"değişikliklerle birlikte diğer dillerden bilinen olağan akış kontrol "
"deyimlerini kullanır."

#: tutorial/controlflow.rst:14
msgid ":keyword:`!if` Statements"
msgstr ":keyword:`!if` İfadeleri"

#: tutorial/controlflow.rst:16
msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` statement.  "
"For example::"
msgstr "Belki de en iyi bilinen deyim türü :keyword:`if` deyimidir.  Örneğin::"

#: tutorial/controlflow.rst:19
msgid ""
">>> x = int(input(\"Please enter an integer: \"))\n"
"Please enter an integer: 42\n"
">>> if x < 0:\n"
"...     x = 0\n"
"...     print('Negative changed to zero')\n"
"... elif x == 0:\n"
"...     print('Zero')\n"
"... elif x == 1:\n"
"...     print('Single')\n"
"... else:\n"
"...     print('More')\n"
"...\n"
"More"
msgstr ""

#: tutorial/controlflow.rst:33
msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`!elif`' is short for 'else if', "
"and is useful to avoid excessive indentation.  An  :keyword:`!if` ... :"
"keyword:`!elif` ... :keyword:`!elif` ... sequence is a substitute for the "
"``switch`` or ``case`` statements found in other languages."
msgstr ""
"Sıfır veya daha fazla :keyword:`elif` bölümü olabilir ve :keyword:`else` "
"bölümü isteğe bağlıdır.  ':keyword:`!elif`' anahtar sözcüğü 'else if' "
"ifadesinin kısaltmasıdır ve aşırı girintiden kaçınmak için kullanışlıdır.  "
"Bir :keyword:`!if` ... :keyword:`!elif` ... :keyword:`!elif` ... dizisi, "
"diğer dillerde bulunan ``switch`` veya ``case`` deyimlerinin yerine geçer."

#: tutorial/controlflow.rst:39
msgid ""
"If you're comparing the same value to several constants, or checking for "
"specific types or attributes, you may also find the :keyword:`!match` "
"statement useful. For more details see :ref:`tut-match`."
msgstr ""
"Aynı değeri birkaç sabitle karşılaştırıyorsanız veya belirli türleri veya "
"nitelikleri kontrol ediyorsanız, :keyword:`!match` deyimini de yararlı "
"bulabilirsiniz. Daha fazla ayrıntı için :ref:`tut-match` bölümüne bakınız."

#: tutorial/controlflow.rst:46
msgid ":keyword:`!for` Statements"
msgstr ":keyword:`!for` İfadeleri"

#: tutorial/controlflow.rst:51
msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be "
"used to in C or Pascal.  Rather than always iterating over an arithmetic "
"progression of numbers (like in Pascal), or giving the user the ability to "
"define both the iteration step and halting condition (as C), Python's :"
"keyword:`!for` statement iterates over the items of any sequence (a list or "
"a string), in the order that they appear in the sequence.  For example (no "
"pun intended):"
msgstr ""
"Python'daki :keyword:`for` deyimi, C veya Pascal'da alışkın olduğunuzdan "
"biraz farklıdır.  Her zaman sayıların aritmetik ilerlemesi üzerinde yineleme "
"yapmak (Pascal'daki gibi) veya kullanıcıya hem yineleme adımını hem de durma "
"koşulunu tanımlama yeteneği vermek (C gibi) yerine, Python'un :keyword:`!"
"for` deyimi, herhangi bir dizinin (bir liste veya bir dize) öğeleri "
"üzerinde, dizide göründükleri sırayla yineler.  Örneğin (kelime oyunu yapmak "
"istemedim):"

#: tutorial/controlflow.rst:63
msgid ""
">>> # Measure some strings:\n"
">>> words = ['cat', 'window', 'defenestrate']\n"
">>> for w in words:\n"
"...     print(w, len(w))\n"
"...\n"
"cat 3\n"
"window 6\n"
"defenestrate 12"
msgstr ""

#: tutorial/controlflow.rst:72
msgid ""
"Code that modifies a collection while iterating over that same collection "
"can be tricky to get right.  Instead, it is usually more straight-forward to "
"loop over a copy of the collection or to create a new collection::"
msgstr ""
"Aynı koleksiyon üzerinde yineleme yaparken bir koleksiyonu değiştiren kodun "
"doğru yazılması zor olabilir.  Bunun yerine, koleksiyonun bir kopyası "
"üzerinde döngü yapmak veya yeni bir koleksiyon oluşturmak genellikle daha "
"kolaydır::"

#: tutorial/controlflow.rst:76
msgid ""
"# Create a sample collection\n"
"users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n"
"\n"
"# Strategy:  Iterate over a copy\n"
"for user, status in users.copy().items():\n"
"    if status == 'inactive':\n"
"        del users[user]\n"
"\n"
"# Strategy:  Create a new collection\n"
"active_users = {}\n"
"for user, status in users.items():\n"
"    if status == 'active':\n"
"        active_users[user] = status"
msgstr ""

#: tutorial/controlflow.rst:94
msgid "The :func:`range` Function"
msgstr ":func:`range` Fonksiyonu"

#: tutorial/controlflow.rst:96
msgid ""
"If you do need to iterate over a sequence of numbers, the built-in function :"
"func:`range` comes in handy.  It generates arithmetic progressions::"
msgstr ""
"Bir sayı dizisi üzerinde yineleme yapmanız gerekiyorsa, yerleşik :func:"
"`range` fonksiyonu kullanışlı olur.  Aritmetik ilerlemeler üretir::"

#: tutorial/controlflow.rst:99
msgid ""
">>> for i in range(5):\n"
"...     print(i)\n"
"...\n"
"0\n"
"1\n"
"2\n"
"3\n"
"4"
msgstr ""

#: tutorial/controlflow.rst:108
msgid ""
"The given end point is never part of the generated sequence; ``range(10)`` "
"generates 10 values, the legal indices for items of a sequence of length "
"10.  It is possible to let the range start at another number, or to specify "
"a different increment (even negative; sometimes this is called the 'step')::"
msgstr ""
"Verilen bitiş noktası asla oluşturulan dizinin bir parçası değildir; "
"``range(10)`` 10 değer üretir, 10 uzunluğundaki bir dizinin öğeleri için "
"yasal indisler.  Aralığın başka bir sayıdan başlamasına izin vermek veya "
"farklı bir artış (negatif bile olsa; bazen buna 'adım' denir) belirtmek "
"mümkündür::"

#: tutorial/controlflow.rst:113
msgid ""
">>> list(range(5, 10))\n"
"[5, 6, 7, 8, 9]\n"
"\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
"\n"
">>> list(range(-10, -100, -30))\n"
"[-10, -40, -70]"
msgstr ""

#: tutorial/controlflow.rst:122
msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` "
"and :func:`len` as follows::"
msgstr ""
"Bir dizinin indisleri üzerinde yineleme yapmak için :func:`range` ve :func:"
"`len` öğelerini aşağıdaki gibi birleştirebilirsiniz::"

#: tutorial/controlflow.rst:125
msgid ""
">>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n"
">>> for i in range(len(a)):\n"
"...     print(i, a[i])\n"
"...\n"
"0 Mary\n"
"1 had\n"
"2 a\n"
"3 little\n"
"4 lamb"
msgstr ""

#: tutorial/controlflow.rst:135
msgid ""
"In most such cases, however, it is convenient to use the :func:`enumerate` "
"function, see :ref:`tut-loopidioms`."
msgstr ""
"Ancak bu tür durumların çoğunda :func:`enumerate` fonksiyonunu kullanmak "
"uygundur, bkz :ref:`tut-loopidioms`."

#: tutorial/controlflow.rst:138
msgid "A strange thing happens if you just print a range::"
msgstr "Sadece bir aralık yazdırırsanız garip bir şey olur::"

#: tutorial/controlflow.rst:140
msgid ""
">>> range(10)\n"
"range(0, 10)"
msgstr ""

#: tutorial/controlflow.rst:143
msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
"Birçok yönden :func:`range` tarafından döndürülen nesne bir listeymiş gibi "
"davranır, ancak aslında öyle değildir. Üzerinde yineleme yaptığınızda "
"istenen dizinin ardışık öğelerini döndüren bir nesnedir, ancak listeyi "
"gerçekten oluşturmaz, böylece yerden tasarruf sağlar."

#: tutorial/controlflow.rst:148
msgid ""
"We say such an object is :term:`iterable`, that is, suitable as a target for "
"functions and constructs that expect something from which they can obtain "
"successive items until the supply is exhausted.  We have seen that the :"
"keyword:`for` statement is such a construct, while an example of a function "
"that takes an iterable is :func:`sum`::"
msgstr ""
"Böyle bir nesnenin :term:`iterable` olduğunu, yani arz tükenene kadar "
"ardışık öğeler elde edebilecekleri bir şey bekleyen fonksiyonlar ve yapılar "
"için bir hedef olarak uygun olduğunu söylüyoruz.  Daha önce :keyword:`for` "
"deyiminin böyle bir yapı olduğunu görmüştük, bir yinelenebilir alan bir "
"fonksiyon örneği ise :func:`sum`::"

#: tutorial/controlflow.rst:154
msgid ""
">>> sum(range(4))  # 0 + 1 + 2 + 3\n"
"6"
msgstr ""

#: tutorial/controlflow.rst:157
msgid ""
"Later we will see more functions that return iterables and take iterables as "
"arguments.  In chapter :ref:`tut-structures`, we will discuss in more detail "
"about :func:`list`."
msgstr ""
"Daha sonra yinelenebilirleri döndüren ve argüman olarak yinelenebilirleri "
"alan daha fazla fonksiyon göreceğiz. :ref:`tut-structures` bölümünde, :func:"
"`list` hakkında daha ayrıntılı olarak tartışacağız."

#: tutorial/controlflow.rst:164
#, fuzzy
msgid ":keyword:`!break` and :keyword:`!continue` Statements"
msgstr ""
":keyword:`!break` ve :keyword:`!continue` İfadeleri ve :keyword:`!else` "
"Döngülerdeki Cümleler"

#: tutorial/controlflow.rst:166
#, fuzzy
msgid ""
"The :keyword:`break` statement breaks out of the innermost enclosing :"
"keyword:`for` or :keyword:`while` loop::"
msgstr ""
"C'de olduğu gibi :keyword:`break` deyimi, en içteki :keyword:`for` veya :"
"keyword:`while` döngüsünü keser."

#: tutorial/controlflow.rst:169
msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(f\"{n} equals {x} * {n//x}\")\n"
"...             break\n"
"...\n"
"4 equals 2 * 2\n"
"6 equals 2 * 3\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""

#: tutorial/controlflow.rst:180
#, fuzzy
msgid ""
"The :keyword:`continue` statement continues with the next iteration of the "
"loop::"
msgstr ""
"Yine C'den ödünç alınan :keyword:`continue` deyimi, döngünün bir sonraki "
"yinelemesiyle devam eder::"

#: tutorial/controlflow.rst:183
msgid ""
">>> for num in range(2, 10):\n"
"...     if num % 2 == 0:\n"
"...         print(f\"Found an even number {num}\")\n"
"...         continue\n"
"...     print(f\"Found an odd number {num}\")\n"
"...\n"
"Found an even number 2\n"
"Found an odd number 3\n"
"Found an even number 4\n"
"Found an odd number 5\n"
"Found an even number 6\n"
"Found an odd number 7\n"
"Found an even number 8\n"
"Found an odd number 9"
msgstr ""

#: tutorial/controlflow.rst:202
#, fuzzy
msgid ":keyword:`!else` Clauses on Loops"
msgstr ":keyword:`!pass` İfadeleri"

#: tutorial/controlflow.rst:204
msgid ""
"In a :keyword:`!for` or :keyword:`!while` loop the :keyword:`!break` "
"statement may be paired with an :keyword:`!else` clause.  If the loop "
"finishes without executing the :keyword:`!break`, the :keyword:`!else` "
"clause executes."
msgstr ""

#: tutorial/controlflow.rst:208
msgid ""
"In a :keyword:`for` loop, the :keyword:`!else` clause is executed after the "
"loop finishes its final iteration, that is, if no break occurred."
msgstr ""

#: tutorial/controlflow.rst:211
msgid ""
"In a :keyword:`while` loop, it's executed after the loop's condition becomes "
"false."
msgstr ""

#: tutorial/controlflow.rst:213
msgid ""
"In either kind of loop, the :keyword:`!else` clause is **not** executed if "
"the loop was terminated by a :keyword:`break`.  Of course, other ways of "
"ending the loop early, such as a :keyword:`return` or a raised exception, "
"will also skip execution of the :keyword:`else` clause."
msgstr ""

#: tutorial/controlflow.rst:218
msgid ""
"This is exemplified in the following :keyword:`!for` loop, which searches "
"for prime numbers::"
msgstr ""

#: tutorial/controlflow.rst:221
msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(n, 'equals', x, '*', n//x)\n"
"...             break\n"
"...     else:\n"
"...         # loop fell through without finding a factor\n"
"...         print(n, 'is a prime number')\n"
"...\n"
"2 is a prime number\n"
"3 is a prime number\n"
"4 equals 2 * 2\n"
"5 is a prime number\n"
"6 equals 2 * 3\n"
"7 is a prime number\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""

#: tutorial/controlflow.rst:239
#, fuzzy
msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause belongs "
"to the ``for`` loop, **not** the ``if`` statement.)"
msgstr ""
"(Evet, bu doğru koddur.  Yakından bakın: ``else`` cümlesi :keyword:`for` "
"döngüsüne aittir, **değil** :keyword:`if` deyimine)"

#: tutorial/controlflow.rst:242
msgid ""
"One way to think of the else clause is to imagine it paired with the ``if`` "
"inside the loop.  As the loop executes, it will run a sequence like if/if/if/"
"else. The ``if`` is inside the loop, encountered a number of times. If the "
"condition is ever true, a ``break`` will happen. If the condition is never "
"true, the ``else`` clause outside the loop will execute."
msgstr ""

#: tutorial/controlflow.rst:248
#, fuzzy
msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does with that of "
"``if`` statements: a ``try`` statement's ``else`` clause runs when no "
"exception occurs, and a loop's ``else`` clause runs when no ``break`` "
"occurs. For more on the ``try`` statement and exceptions, see :ref:`tut-"
"handling`."
msgstr ""
"Bir döngü ile kullanıldığında, ``else`` ifadesinin :keyword:`try` deyiminin "
"``else`` cümlesiyle, :keyword:`if` deyimlerininkinden daha fazla ortak "
"noktası vardır: :keyword:`try` deyiminin ``else`` cümlesi herhangi bir "
"istisna oluşmadığında çalışır ve bir döngünün ``else`` cümlesi herhangi bir "
"``break`` oluşmadığında çalışır. :keyword:`!try` deyimi ve istisnalar "
"hakkında daha fazla bilgi için :ref:`tut-handling` bölümüne bakınız."

#: tutorial/controlflow.rst:257
msgid ":keyword:`!pass` Statements"
msgstr ":keyword:`!pass` İfadeleri"

#: tutorial/controlflow.rst:259
msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a statement "
"is required syntactically but the program requires no action. For example::"
msgstr ""
":keyword:`pass` deyimi hiçbir şey yapmaz. Sözdizimsel olarak bir deyim "
"gerektiğinde ancak program hiçbir eylem gerektirmediğinde kullanılabilir. "
"Örneğin::"

#: tutorial/controlflow.rst:262
msgid ""
">>> while True:\n"
"...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n"
"..."
msgstr ""

#: tutorial/controlflow.rst:266
msgid "This is commonly used for creating minimal classes::"
msgstr "Bu genellikle minimal sınıflar oluşturmak için kullanılır::"

#: tutorial/controlflow.rst:268
msgid ""
">>> class MyEmptyClass:\n"
"...     pass\n"
"..."
msgstr ""

#: tutorial/controlflow.rst:272
msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing you "
"to keep thinking at a more abstract level.  The :keyword:`!pass` is silently "
"ignored::"
msgstr ""
":keyword:`pass` 'in kullanılabileceği bir başka yer de, yeni kod üzerinde "
"çalışırken bir fonksiyon veya koşul gövdesi için bir yer tutucu olarak daha "
"soyut bir düzeyde düşünmeye devam etmenizi sağlamaktır.  :keyword:`!pass` "
"sessizce göz ardı edilir::"

#: tutorial/controlflow.rst:276
msgid ""
">>> def initlog(*args):\n"
"...     pass   # Remember to implement this!\n"
"..."
msgstr ""

#: tutorial/controlflow.rst:284
msgid ":keyword:`!match` Statements"
msgstr ":keyword:`!pass` İfadeleri"

#: tutorial/controlflow.rst:286
msgid ""
"A :keyword:`match` statement takes an expression and compares its value to "
"successive patterns given as one or more case blocks.  This is superficially "
"similar to a switch statement in C, Java or JavaScript (and many other "
"languages), but it's more similar to pattern matching in languages like Rust "
"or Haskell. Only the first pattern that matches gets executed and it can "
"also extract components (sequence elements or object attributes) from the "
"value into variables."
msgstr ""
":keyword:`match` bir ifadeyi alır ve değerini bir veya daha fazla case bloğu "
"olarak verilen ardışık kalıplarla karşılaştırır.  Bu, C, Java veya "
"JavaScript'teki (ve diğer birçok dildeki) bir switch ifadesine yüzeysel "
"olarak benzer, ancak Rust veya Haskell gibi dillerdeki kalıp eşleştirmeye "
"daha çok benzer. Yalnızca eşleşen ilk kalıp yürütülür ve ayrıca bileşenleri "
"(sıra öğeleri veya nesne nitelikleri) değerden değişkenlere çıkarabilir."

#: tutorial/controlflow.rst:294
msgid ""
"The simplest form compares a subject value against one or more literals::"
msgstr ""
"En basit form, bir konu değerini bir veya daha fazla sabitle karşılaştırır::"

#: tutorial/controlflow.rst:296
msgid ""
"def http_error(status):\n"
"    match status:\n"
"        case 400:\n"
"            return \"Bad request\"\n"
"        case 404:\n"
"            return \"Not found\"\n"
"        case 418:\n"
"            return \"I'm a teapot\"\n"
"        case _:\n"
"            return \"Something's wrong with the internet\""
msgstr ""

#: tutorial/controlflow.rst:307
msgid ""
"Note the last block: the \"variable name\" ``_`` acts as a *wildcard* and "
"never fails to match. If no case matches, none of the branches is executed."
msgstr ""
"Son bloğa dikkat edin: \"değişken adı\" ``_`` bir *wildcard* görevi görür ve "
"asla eşleşmez. Hiçbir durum eşleşmezse, dallardan hiçbiri yürütülmez."

#: tutorial/controlflow.rst:310
msgid ""
"You can combine several literals in a single pattern using ``|`` (\"or\")::"
msgstr ""
"``|`` (\"or\") kullanarak birkaç sabiti tek bir kalıpta "
"birleştirebilirsiniz::"

#: tutorial/controlflow.rst:312
msgid ""
"case 401 | 403 | 404:\n"
"    return \"Not allowed\""
msgstr ""

#: tutorial/controlflow.rst:315
msgid ""
"Patterns can look like unpacking assignments, and can be used to bind "
"variables::"
msgstr ""
"Kalıplar paket açma atamaları gibi görünebilir ve değişkenleri bağlamak için "
"kullanılabilir::"

#: tutorial/controlflow.rst:318
msgid ""
"# point is an (x, y) tuple\n"
"match point:\n"
"    case (0, 0):\n"
"        print(\"Origin\")\n"
"    case (0, y):\n"
"        print(f\"Y={y}\")\n"
"    case (x, 0):\n"
"        print(f\"X={x}\")\n"
"    case (x, y):\n"
"        print(f\"X={x}, Y={y}\")\n"
"    case _:\n"
"        raise ValueError(\"Not a point\")"
msgstr ""

#: tutorial/controlflow.rst:331
msgid ""
"Study that one carefully!  The first pattern has two literals, and can be "
"thought of as an extension of the literal pattern shown above.  But the next "
"two patterns combine a literal and a variable, and the variable *binds* a "
"value from the subject (``point``).  The fourth pattern captures two values, "
"which makes it conceptually similar to the unpacking assignment ``(x, y) = "
"point``."
msgstr ""
"Bunu dikkatle inceleyin!  İlk kalıpta iki sabit vardır ve yukarıda "
"gösterilen sabit kalıbının bir uzantısı olarak düşünülebilir.  Ancak sonraki "
"iki kalıp bir sabit ve bir değişkeni birleştirir ve değişken özneden "
"(``point``) bir değer *bağlar*.  Dördüncü kalıp iki değeri yakalar, bu da "
"onu kavramsal olarak ``(x, y) = point`` paket açma atamasına benzer hale "
"getirir."

#: tutorial/controlflow.rst:338
msgid ""
"If you are using classes to structure your data you can use the class name "
"followed by an argument list resembling a constructor, but with the ability "
"to capture attributes into variables::"
msgstr ""
"Verilerinizi yapılandırmak için sınıfları kullanıyorsanız, sınıf adını ve "
"ardından bir yapıcıya benzeyen, ancak nitelikleri değişkenlere yakalama "
"yeteneğine sahip bir argüman listesi kullanabilirsiniz::"

#: tutorial/controlflow.rst:342
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"def where_is(point):\n"
"    match point:\n"
"        case Point(x=0, y=0):\n"
"            print(\"Origin\")\n"
"        case Point(x=0, y=y):\n"
"            print(f\"Y={y}\")\n"
"        case Point(x=x, y=0):\n"
"            print(f\"X={x}\")\n"
"        case Point():\n"
"            print(\"Somewhere else\")\n"
"        case _:\n"
"            print(\"Not a point\")"
msgstr ""

#: tutorial/controlflow.rst:360
msgid ""
"You can use positional parameters with some builtin classes that provide an "
"ordering for their attributes (e.g. dataclasses). You can also define a "
"specific position for attributes in patterns by setting the "
"``__match_args__`` special attribute in your classes. If it's set to (\"x\", "
"\"y\"), the following patterns are all equivalent (and all bind the ``y`` "
"attribute to the ``var`` variable)::"
msgstr ""
"Konumsal parametreleri, nitelikleri için bir sıralama sağlayan bazı yerleşik "
"sınıflarla (örneğin veri sınıfları) kullanabilirsiniz. Ayrıca sınıflarınızda "
"``__match_args__`` niteliğini ayarlayarak kalıplardaki nitelikler için "
"belirli bir konum tanımlayabilirsiniz. Bu özellik (\"x\", \"y\") olarak "
"ayarlanırsa, bahsi geçen kalıpların hepsi eş değerdir (ve hepsi ``y`` "
"niteliğini ``var`` değişkenine bağlar)::"

#: tutorial/controlflow.rst:366
msgid ""
"Point(1, var)\n"
"Point(1, y=var)\n"
"Point(x=1, y=var)\n"
"Point(y=var, x=1)"
msgstr ""

#: tutorial/controlflow.rst:371
msgid ""
"A recommended way to read patterns is to look at them as an extended form of "
"what you would put on the left of an assignment, to understand which "
"variables would be set to what. Only the standalone names (like ``var`` "
"above) are assigned to by a match statement. Dotted names (like ``foo."
"bar``), attribute names (the ``x=`` and ``y=`` above) or class names "
"(recognized by the \"(...)\" next to them like ``Point`` above) are never "
"assigned to."
msgstr ""
"Kalıpları okumak için önerilen bir yol, hangi değişkenlerin neye "
"ayarlanacağını anlamak için onlara bir atamanın soluna koyacağınız şeyin "
"genişletilmiş bir biçimi olarak bakmaktır. Yalnızca bağımsız isimler "
"(yukarıdaki ``var`` gibi) bir eşleştirme deyimi tarafından atanır. Noktalı "
"isimlere (``foo.bar`` gibi), nitelik isimlerine (yukarıdaki ``x=`` ve ``y=`` "
"gibi) veya sınıf isimlerine (yukarıdaki ``Point`` gibi yanlarındaki "
"\"(...)\" ile tanınan) asla atama yapılmaz."

#: tutorial/controlflow.rst:378
#, fuzzy
msgid ""
"Patterns can be arbitrarily nested.  For example, if we have a short list of "
"Points, with ``__match_args__`` added, we could match it like this::"
msgstr ""
"Kalıplar keyfi olarak iç içe geçebilir.  Örneğin, kısa bir nokta listemiz "
"varsa, bunu şu şekilde eşleştirebiliriz::"

#: tutorial/controlflow.rst:381
msgid ""
"class Point:\n"
"    __match_args__ = ('x', 'y')\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"match points:\n"
"    case []:\n"
"        print(\"No points\")\n"
"    case [Point(0, 0)]:\n"
"        print(\"The origin\")\n"
"    case [Point(x, y)]:\n"
"        print(f\"Single point {x}, {y}\")\n"
"    case [Point(0, y1), Point(0, y2)]:\n"
"        print(f\"Two on the Y axis at {y1}, {y2}\")\n"
"    case _:\n"
"        print(\"Something else\")"
msgstr ""

#: tutorial/controlflow.rst:399
msgid ""
"We can add an ``if`` clause to a pattern, known as a \"guard\".  If the "
"guard is false, ``match`` goes on to try the next case block.  Note that "
"value capture happens before the guard is evaluated::"
msgstr ""
"Bir kalıba \"guard\" olarak bilinen bir ``if`` cümlesi ekleyebiliriz.  Eğer "
"guard yanlış ise, ``match`` bir sonraki case bloğunu denemeye devam eder.  "
"Değer yakalamanın koruma değerlendirilmeden önce gerçekleştiğine dikkat "
"edin::"

#: tutorial/controlflow.rst:403
msgid ""
"match point:\n"
"    case Point(x, y) if x == y:\n"
"        print(f\"Y=X at {x}\")\n"
"    case Point(x, y):\n"
"        print(f\"Not on the diagonal\")"
msgstr ""

#: tutorial/controlflow.rst:409
msgid "Several other key features of this statement:"
msgstr "Bu açıklamanın diğer bazı kilit özellikleri:"

#: tutorial/controlflow.rst:411
msgid ""
"Like unpacking assignments, tuple and list patterns have exactly the same "
"meaning and actually match arbitrary sequences.  An important exception is "
"that they don't match iterators or strings."
msgstr ""
"Paket açma atamaları gibi, tuple ve liste kalıpları da tamamen aynı anlama "
"sahiptir ve aslında rastgele dizilerle eşleşir.  Önemli bir istisna, "
"yineleyicilerle veya string'lerle eşleşmezler."

#: tutorial/controlflow.rst:415
msgid ""
"Sequence patterns support extended unpacking: ``[x, y, *rest]`` and ``(x, y, "
"*rest)`` work similar to unpacking assignments.  The name after ``*`` may "
"also be ``_``, so ``(x, y, *_)`` matches a sequence of at least two items "
"without binding the remaining items."
msgstr ""
"Sıra kalıpları genişletilmiş paket açmayı destekler: ``[x, y, *rest]`` ve "
"``(x, y, *rest)`` paket açma atamalarına benzer şekilde çalışır.  ``*`` "
"öğesinden sonraki ad ``_`` de olabilir, bu nedenle ``(x, y, *_)`` öğesi, "
"kalan öğeleri bağlamadan en az iki öğeden oluşan bir diziyle eşleşir."

#: tutorial/controlflow.rst:420
msgid ""
"Mapping patterns: ``{\"bandwidth\": b, \"latency\": l}`` captures the "
"``\"bandwidth\"`` and ``\"latency\"`` values from a dictionary.  Unlike "
"sequence patterns, extra keys are ignored.  An unpacking like ``**rest`` is "
"also supported.  (But ``**_`` would be redundant, so it is not allowed.)"
msgstr ""
"Eşleme kalıpları: ``{\"bandwidth\": b, \"latency\": l}`` bir sözlükten "
"``\"bandwidth\"`` ve ``\"latency\"`` değerlerini yakalar.  Sıra kalıplarının "
"aksine, ekstra anahtarlar göz ardı edilir.  ``**rest`` gibi bir paket açma "
"da desteklenir.  (Ancak ``**_`` gereksiz olacağından buna izin verilmez)"

#: tutorial/controlflow.rst:425
msgid "Subpatterns may be captured using the ``as`` keyword::"
msgstr "Alt kalıplar ``as`` anahtar sözcüğü kullanılarak yakalanabilir::"

#: tutorial/controlflow.rst:427
msgid "case (Point(x1, y1), Point(x2, y2) as p2): ..."
msgstr ""

#: tutorial/controlflow.rst:429
msgid ""
"will capture the second element of the input as ``p2`` (as long as the input "
"is a sequence of two points)"
msgstr ""
"girdinin ikinci elemanını ``p2`` olarak yakalayacaktır (girdi iki noktadan "
"oluşan bir dizi olduğu sürece)"

#: tutorial/controlflow.rst:432
msgid ""
"Most literals are compared by equality, however the singletons ``True``, "
"``False`` and ``None`` are compared by identity."
msgstr ""
"Çoğu sabit eşitlikle karşılaştırılır, ancak ``True``, ``False`` ve ``None`` "
"tekilleri özdeşlikle karşılaştırılır."

#: tutorial/controlflow.rst:435
msgid ""
"Patterns may use named constants.  These must be dotted names to prevent "
"them from being interpreted as capture variable::"
msgstr ""
"Kalıplar adlandırılmış sabitler kullanabilir.  Bunlar, yakalama değişkeni "
"olarak yorumlanmalarını önlemek için noktalı isimler olmalıdır::"

#: tutorial/controlflow.rst:438
msgid ""
"from enum import Enum\n"
"class Color(Enum):\n"
"    RED = 'red'\n"
"    GREEN = 'green'\n"
"    BLUE = 'blue'\n"
"\n"
"color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\n"
"\n"
"match color:\n"
"    case Color.RED:\n"
"        print(\"I see red!\")\n"
"    case Color.GREEN:\n"
"        print(\"Grass is green\")\n"
"    case Color.BLUE:\n"
"        print(\"I'm feeling the blues :(\")"
msgstr ""

#: tutorial/controlflow.rst:454
msgid ""
"For a more detailed explanation and additional examples, you can look into :"
"pep:`636` which is written in a tutorial format."
msgstr ""
"Daha ayrıntılı bir açıklama ve ek örnekler için, öğretici bir formatta "
"yazılmış olan :pep:`636` sayfasına bakabilirsiniz."

#: tutorial/controlflow.rst:460
msgid "Defining Functions"
msgstr "Fonksiyonların Tanımlanması"

#: tutorial/controlflow.rst:462
msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary "
"boundary::"
msgstr ""
"Fibonacci serisini rastgele bir sınıra kadar yazan bir fonksiyon "
"oluşturabiliriz::"

#: tutorial/controlflow.rst:465
msgid ""
">>> def fib(n):    # write Fibonacci series less than n\n"
"...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         print(a, end=' ')\n"
"...         a, b = b, a+b\n"
"...     print()\n"
"...\n"
">>> # Now call the function we just defined:\n"
">>> fib(2000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"
msgstr ""

#: tutorial/controlflow.rst:482
msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must be "
"followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at the "
"next line, and must be indented."
msgstr ""
"Anahtar kelime :keyword:`def` bir fonksiyon *tanımını* tanıtır.  Bunu "
"fonksiyon adı ve parantez içine alınmış resmi parametreler listesi takip "
"etmelidir. Fonksiyonun gövdesini oluşturan ifadeler bir sonraki satırdan "
"başlar ve girintili olmalıdır."

#: tutorial/controlflow.rst:487
msgid ""
"The first statement of the function body can optionally be a string literal; "
"this string literal is the function's documentation string, or :dfn:"
"`docstring`. (More about docstrings can be found in the section :ref:`tut-"
"docstrings`.) There are tools which use docstrings to automatically produce "
"online or printed documentation, or to let the user interactively browse "
"through code; it's good practice to include docstrings in code that you "
"write, so make a habit of it."
msgstr ""
"Fonksiyon gövdesinin ilk ifadesi isteğe bağlı olarak bir string literal "
"olabilir; bu string literal fonksiyonun dokümantasyon stringi veya :dfn:"
"`docstring` 'dir. (Docstringler hakkında daha fazla bilgi :ref:`tut-"
"docstrings` bölümünde bulunabilir.) Otomatik olarak çevrimiçi veya basılı "
"dokümantasyon üretmek veya kullanıcının etkileşimli olarak kodda gezinmesini "
"sağlamak için docstringleri kullanan araçlar vardır; yazdığınız koda "
"docstringler eklemek iyi bir uygulamadır, bu yüzden bunu alışkanlık haline "
"getirin."

#: tutorial/controlflow.rst:494
msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable assignments "
"in a function store the value in the local symbol table; whereas variable "
"references first look in the local symbol table, then in the local symbol "
"tables of enclosing functions, then in the global symbol table, and finally "
"in the table of built-in names. Thus, global variables and variables of "
"enclosing functions cannot be directly assigned a value within a function "
"(unless, for global variables, named in a :keyword:`global` statement, or, "
"for variables of enclosing functions, named in a :keyword:`nonlocal` "
"statement), although they may be referenced."
msgstr ""
"Bir fonksiyonun *çalıştırılması*, fonksiyonun yerel değişkenleri için "
"kullanılan yeni bir sembol tablosu ortaya çıkarır.  Daha açık bir ifadeyle, "
"bir fonksiyon içindeki tüm değişken atamaları değeri yerel sembol tablosunda "
"saklar; oysa değişken referansları önce yerel sembol tablosuna, sonra "
"çevreleyen fonksiyonların yerel sembol tablolarına, daha sonra global sembol "
"tablosuna ve son olarak da yerleşik isimler tablosuna bakar. Bu nedenle, "
"global değişkenlere ve çevreleyen fonksiyonların değişkenlerine bir "
"fonksiyon içinde doğrudan değer atanamaz (global değişkenler için bir :"
"keyword:`global` deyiminde veya çevreleyen fonksiyonların değişkenleri için "
"bir :keyword:`nonlocal` deyiminde isimlendirilmedikçe), ancak bunlara "
"referans verilebilir."

#: tutorial/controlflow.rst:505
msgid ""
"The actual parameters (arguments) to a function call are introduced in the "
"local symbol table of the called function when it is called; thus, arguments "
"are passed using *call by value* (where the *value* is always an object "
"*reference*, not the value of the object). [#]_ When a function calls "
"another function, or calls itself recursively, a new local symbol table is "
"created for that call."
msgstr ""
"Bir fonksiyon çağrısının gerçek parametreleri (argümanları), çağrıldığında "
"çağrılan fonksiyonun yerel sembol tablosunda tanıtılır; bu nedenle, "
"argümanlar *call by value* (burada *value* her zaman bir nesne "
"*referans*'dır, nesnenin değeri değildir) kullanılarak aktarılır. [#]_ Bir "
"fonksiyon başka bir fonksiyonu çağırdığında veya kendini tekrarlı olarak "
"çağırdığında, bu çağrı için yeni bir yerel sembol tablosu oluşturulur."

#: tutorial/controlflow.rst:512
msgid ""
"A function definition associates the function name with the function object "
"in the current symbol table.  The interpreter recognizes the object pointed "
"to by that name as a user-defined function.  Other names can also point to "
"that same function object and can also be used to access the function::"
msgstr ""
"Bir fonksiyon tanımı, fonksiyon adını geçerli sembol tablosundaki fonksiyon "
"nesnesiyle ilişkilendirir.  Yorumlayıcı, bu adın işaret ettiği nesneyi "
"kullanıcı tanımlı bir fonksiyon olarak tanır.  Diğer isimler de aynı "
"fonksiyon nesnesine işaret edebilir ve fonksiyona erişmek için "
"kullanılabilir::"

#: tutorial/controlflow.rst:517
msgid ""
">>> fib\n"
"<function fib at 10042ed0>\n"
">>> f = fib\n"
">>> f(100)\n"
"0 1 1 2 3 5 8 13 21 34 55 89"
msgstr ""

#: tutorial/controlflow.rst:523
msgid ""
"Coming from other languages, you might object that ``fib`` is not a function "
"but a procedure since it doesn't return a value.  In fact, even functions "
"without a :keyword:`return` statement do return a value, albeit a rather "
"boring one.  This value is called ``None`` (it's a built-in name).  Writing "
"the value ``None`` is normally suppressed by the interpreter if it would be "
"the only value written. You can see it if you really want to using :func:"
"`print`::"
msgstr ""
"Diğer dillerden geliyorsanız, ``fib`` 'in bir fonksiyon değil, değer "
"döndürmediği için bir prosedür olduğuna itiraz edebilirsiniz.  Aslında, :"
"keyword:`return` ifadesi olmayan fonksiyonlar bile, oldukça sıkıcı olsa da, "
"bir değer döndürürler.  Bu değer ``None`` olarak adlandırılır (yerleşik bir "
"isimdir).  Normalde ``None`` değerinin yazılması, yazılan tek değer olacaksa "
"yorumlayıcı tarafından bastırılır. Eğer gerçekten istiyorsanız :func:`print` "
"kullanarak görebilirsiniz::"

#: tutorial/controlflow.rst:530
msgid ""
">>> fib(0)\n"
">>> print(fib(0))\n"
"None"
msgstr ""

#: tutorial/controlflow.rst:534
msgid ""
"It is simple to write a function that returns a list of the numbers of the "
"Fibonacci series, instead of printing it::"
msgstr ""
"Fibonacci serisindeki sayıların listesini döndürebilecek bir fonksiyon "
"yazmak gayet basittir, onun yerine şunu yazdırarak::"

#: tutorial/controlflow.rst:537
msgid ""
">>> def fib2(n):  # return Fibonacci series up to n\n"
"...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n"
"...     result = []\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         result.append(a)    # see below\n"
"...         a, b = b, a+b\n"
"...     return result\n"
"...\n"
">>> f100 = fib2(100)    # call it\n"
">>> f100                # write the result\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
msgstr ""

#: tutorial/controlflow.rst:550
msgid "This example, as usual, demonstrates some new Python features:"
msgstr ""
"Bu örnek, her zamanki gibi, bazı yeni Python özelliklerini göstermektedir:"

#: tutorial/controlflow.rst:552
msgid ""
"The :keyword:`return` statement returns with a value from a function. :"
"keyword:`!return` without an expression argument returns ``None``. Falling "
"off the end of a function also returns ``None``."
msgstr ""
"Bir :keyword:`return` deyimi bir fonksiyondan bir değerle döner. :keyword:`!"
"return` deyimi bir ifade argümanı olmadan ``None`` döndürür. Bir fonksiyonun "
"sonundan düşmek de ``None`` değerini döndürür."

#: tutorial/controlflow.rst:556
#, fuzzy
msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is named "
"``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined by "
"the object's type. Different types define different methods.  Methods of "
"different types may have the same name without causing ambiguity.  (It is "
"possible to define your own object types and methods, using *classes*, see :"
"ref:`tut-classes`) The method :meth:`!append` shown in the example is "
"defined for list objects; it adds a new element at the end of the list.  In "
"this example it is equivalent to ``result = result + [a]``, but more "
"efficient."
msgstr ""
"``result.append(a)`` ifadesi ``result`` liste nesnesinin bir *metodunu* "
"çağırır.  Bir yöntem, bir nesneye 'ait' olan ve ``obj.methodname`` olarak "
"adlandırılan bir işlevdir; burada ``obj`` bir nesnedir (bu bir ifade "
"olabilir) ve ``methodname`` nesnenin türü tarafından tanımlanan bir yöntemin "
"adıdır. Farklı türler farklı yöntemler tanımlar.  Farklı türlerdeki "
"yöntemler, belirsizliğe neden olmadan aynı ada sahip olabilir.  (*classes* "
"kullanarak kendi nesne türlerinizi ve yöntemlerinizi tanımlamak mümkündür, "
"bkz :ref:`tut-classes`) Örnekte gösterilen :meth:`append` yöntemi liste "
"nesneleri için tanımlanmıştır; listenin sonuna yeni bir öğe ekler.  Bu "
"örnekte ``result = result + [a]`` ile eş değerdir, ancak daha verimlidir."

#: tutorial/controlflow.rst:571
msgid "More on Defining Functions"
msgstr "İşlev Tanımlama hakkında daha fazla bilgi"

#: tutorial/controlflow.rst:573
msgid ""
"It is also possible to define functions with a variable number of arguments. "
"There are three forms, which can be combined."
msgstr ""
"Değişken sayıda argüman içeren fonksiyonlar tanımlamak da mümkündür. "
"Birleştirilebilen üç form vardır."

#: tutorial/controlflow.rst:580
msgid "Default Argument Values"
msgstr "Varsayılan Değişken Değerleri"

#: tutorial/controlflow.rst:582
msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer arguments "
"than it is defined to allow.  For example::"
msgstr ""
"En kullanışlı biçim, bir veya daha fazla bağımsız değişken için varsayılan "
"bir değer belirtmektir. Bu, izin vermek üzere tanımlandığından daha az "
"sayıda bağımsız değişkenle çağrılabilen bir fonksiyon oluşturur.  Örneğin::"

#: tutorial/controlflow.rst:586
msgid ""
"def ask_ok(prompt, retries=4, reminder='Please try again!'):\n"
"    while True:\n"
"        reply = input(prompt)\n"
"        if reply in {'y', 'ye', 'yes'}:\n"
"            return True\n"
"        if reply in {'n', 'no', 'nop', 'nope'}:\n"
"            return False\n"
"        retries = retries - 1\n"
"        if retries < 0:\n"
"            raise ValueError('invalid user response')\n"
"        print(reminder)"
msgstr ""

#: tutorial/controlflow.rst:598
msgid "This function can be called in several ways:"
msgstr "Bu fonksiyon çeşitli yollarla çağrılabilir:"

#: tutorial/controlflow.rst:600
msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to quit?')``"
msgstr ""
"sadece zorunlu argümanı vererek: ``ask_ok('Gerçekten çıkmak istiyor "
"musun?')``"

#: tutorial/controlflow.rst:602
msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the file?', "
"2)``"
msgstr ""
"isteğe bağlı değişkenlerden birini vermek: ``ask_ok('OK to overwrite the "
"file?', 2)``"

#: tutorial/controlflow.rst:604
msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, 'Come "
"on, only yes or no!')``"
msgstr ""
"ya da bütün değişkenleri vermek: ``ask_ok('OK to overwrite the file?', 2, "
"'Come on, only yes or no!')``"

#: tutorial/controlflow.rst:607
msgid ""
"This example also introduces the :keyword:`in` keyword. This tests whether "
"or not a sequence contains a certain value."
msgstr ""
"Bu örnek ayrıca :keyword:`in` anahtar sözcüğünü de tanıtır. Bu, bir dizinin "
"belirli bir değer içerip içermediğini test eder."

#: tutorial/controlflow.rst:610
msgid ""
"The default values are evaluated at the point of function definition in the "
"*defining* scope, so that ::"
msgstr ""
"Varsayılan değerler *tanımlayan* kapsamdaki fonksiyon tanımlama noktasında "
"değerlendirilir, böylece ::"

#: tutorial/controlflow.rst:613
msgid ""
"i = 5\n"
"\n"
"def f(arg=i):\n"
"    print(arg)\n"
"\n"
"i = 6\n"
"f()"
msgstr ""

#: tutorial/controlflow.rst:621
msgid "will print ``5``."
msgstr "``5`` çıktısını verecektir."

#: tutorial/controlflow.rst:623
msgid ""
"**Important warning:**  The default value is evaluated only once. This makes "
"a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**Önemli uyarı:** Varsayılan değer yalnızca bir kez değerlendirilir. "
"Varsayılan değer liste, sözlük veya çoğu sınıfın örnekleri gibi "
"değiştirilebilir bir nesne olduğunda bu durum fark yaratır.  Örneğin, "
"aşağıdaki fonksiyon sonraki çağrılarda kendisine aktarılan argümanları "
"biriktirir::"

#: tutorial/controlflow.rst:628
msgid ""
"def f(a, L=[]):\n"
"    L.append(a)\n"
"    return L\n"
"\n"
"print(f(1))\n"
"print(f(2))\n"
"print(f(3))"
msgstr ""

#: tutorial/controlflow.rst:636
msgid "This will print ::"
msgstr "Bu şu çıktıyı verecektir ::"

#: tutorial/controlflow.rst:638
msgid ""
"[1]\n"
"[1, 2]\n"
"[1, 2, 3]"
msgstr ""

#: tutorial/controlflow.rst:642
msgid ""
"If you don't want the default to be shared between subsequent calls, you can "
"write the function like this instead::"
msgstr ""
"Varsayılan değerin sonraki çağrılar arasında paylaşılmasını istemiyorsanız, "
"bunun yerine fonksiyonu şu şekilde yazabilirsiniz::"

#: tutorial/controlflow.rst:645
msgid ""
"def f(a, L=None):\n"
"    if L is None:\n"
"        L = []\n"
"    L.append(a)\n"
"    return L"
msgstr ""

#: tutorial/controlflow.rst:655
msgid "Keyword Arguments"
msgstr "Anahtar Kelime Değişkenleri"

#: tutorial/controlflow.rst:657
msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"Fonksiyonlar ayrıca ``kwarg=value`` şeklinde :term:`anahtar kelime "
"argümanları <keyword argument>` kullanılarak da çağrılabilir.  Örneğin, "
"aşağıdaki fonksiyon::"

#: tutorial/controlflow.rst:660
msgid ""
"def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\n"
"    print(\"-- This parrot wouldn't\", action, end=' ')\n"
"    print(\"if you put\", voltage, \"volts through it.\")\n"
"    print(\"-- Lovely plumage, the\", type)\n"
"    print(\"-- It's\", state, \"!\")"
msgstr ""

#: tutorial/controlflow.rst:666
msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in any "
"of the following ways::"
msgstr ""
"bir gerekli argüman (``voltage``) ve üç isteğe bağlı argüman (``state``, "
"``action`` ve ``type``) kabul eder.  Bu fonksiyon aşağıdaki yollardan "
"herhangi biriyle çağrılabilir::"

#: tutorial/controlflow.rst:670
msgid ""
"parrot(1000)                                          # 1 positional "
"argument\n"
"parrot(voltage=1000)                                  # 1 keyword argument\n"
"parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\n"
"parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\n"
"parrot('a million', 'bereft of life', 'jump')         # 3 positional "
"arguments\n"
"parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 "
"keyword"
msgstr ""

#: tutorial/controlflow.rst:677
msgid "but all the following calls would be invalid::"
msgstr "ancak aşağıdaki tüm çağrılar geçersiz olacaktır::"

#: tutorial/controlflow.rst:679
msgid ""
"parrot()                     # required argument missing\n"
"parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword "
"argument\n"
"parrot(110, voltage=220)     # duplicate value for the same argument\n"
"parrot(actor='John Cleese')  # unknown keyword argument"
msgstr ""

#: tutorial/controlflow.rst:684
msgid ""
"In a function call, keyword arguments must follow positional arguments. All "
"the keyword arguments passed must match one of the arguments accepted by the "
"function (e.g. ``actor`` is not a valid argument for the ``parrot`` "
"function), and their order is not important.  This also includes non-"
"optional arguments (e.g. ``parrot(voltage=1000)`` is valid too). No argument "
"may receive a value more than once. Here's an example that fails due to this "
"restriction::"
msgstr ""
"Bir fonksiyon çağrısında, anahtar kelime argümanları konumsal argümanları "
"takip etmelidir. Aktarılan tüm anahtar sözcük argümanları fonksiyon "
"tarafından kabul edilen argümanlardan biriyle eşleşmelidir (örneğin "
"``actor`` ``parrot`` fonksiyonu için geçerli bir argüman değildir) ve "
"sıraları önemli değildir.  Buna isteğe bağlı olmayan argümanlar da dahildir "
"(örneğin ``parrot(voltage=1000)`` da geçerlidir). Hiçbir argüman birden "
"fazla değer alamaz. İşte bu kısıtlama nedeniyle başarısız olan bir örnek::"

#: tutorial/controlflow.rst:692
msgid ""
">>> def function(a):\n"
"...     pass\n"
"...\n"
">>> function(0, a=0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: function() got multiple values for argument 'a'"
msgstr ""

#: tutorial/controlflow.rst:700
msgid ""
"When a final formal parameter of the form ``**name`` is present, it receives "
"a dictionary (see :ref:`typesmapping`) containing all keyword arguments "
"except for those corresponding to a formal parameter.  This may be combined "
"with a formal parameter of the form ``*name`` (described in the next "
"subsection) which receives a :ref:`tuple <tut-tuples>` containing the "
"positional arguments beyond the formal parameter list.  (``*name`` must "
"occur before ``**name``.) For example, if we define a function like this::"
msgstr ""
"``**name`` biçiminde bir son biçimsel parametre mevcut olduğunda, biçimsel "
"parametreye karşılık gelenler dışındaki tüm anahtar kelime argümanlarını "
"içeren bir sözlük alır (bkz. :ref:`typesmapping`).  Bu, biçimsel parametre :"
"ref:`tuple <tut-tuples>` listesinin ötesindeki konumsal argümanları içeren "
"bir ``*name`` biçimindeki bir biçimsel parametre ile birleştirilebilir (bir "
"sonraki alt bölümde açıklanmıştır).  (``*name``, ``**name`` 'den önce "
"gelmelidir.) Örneğin, aşağıdaki gibi bir fonksiyon tanımlarsak::"

#: tutorial/controlflow.rst:708
msgid ""
"def cheeseshop(kind, *arguments, **keywords):\n"
"    print(\"-- Do you have any\", kind, \"?\")\n"
"    print(\"-- I'm sorry, we're all out of\", kind)\n"
"    for arg in arguments:\n"
"        print(arg)\n"
"    print(\"-\" * 40)\n"
"    for kw in keywords:\n"
"        print(kw, \":\", keywords[kw])"
msgstr ""

#: tutorial/controlflow.rst:717
msgid "It could be called like this::"
msgstr "Şöyle denebilir::"

#: tutorial/controlflow.rst:719
msgid ""
"cheeseshop(\"Limburger\", \"It's very runny, sir.\",\n"
"           \"It's really very, VERY runny, sir.\",\n"
"           shopkeeper=\"Michael Palin\",\n"
"           client=\"John Cleese\",\n"
"           sketch=\"Cheese Shop Sketch\")"
msgstr ""

#: tutorial/controlflow.rst:725
msgid "and of course it would print:"
msgstr "ve tabii ki yazdıracaktır:"

#: tutorial/controlflow.rst:727
msgid ""
"-- Do you have any Limburger ?\n"
"-- I'm sorry, we're all out of Limburger\n"
"It's very runny, sir.\n"
"It's really very, VERY runny, sir.\n"
"----------------------------------------\n"
"shopkeeper : Michael Palin\n"
"client : John Cleese\n"
"sketch : Cheese Shop Sketch"
msgstr ""

#: tutorial/controlflow.rst:738
msgid ""
"Note that the order in which the keyword arguments are printed is guaranteed "
"to match the order in which they were provided in the function call."
msgstr ""
"Anahtar sözcük bağımsız değişkenlerinin yazdırılma sırasının, fonksiyon "
"çağrısında sağlandıkları sırayla eşleşmesinin garanti edildiğini unutmayın."

#: tutorial/controlflow.rst:742
msgid "Special parameters"
msgstr "Özel parametreler"

#: tutorial/controlflow.rst:744
msgid ""
"By default, arguments may be passed to a Python function either by position "
"or explicitly by keyword. For readability and performance, it makes sense to "
"restrict the way arguments can be passed so that a developer need only look "
"at the function definition to determine if items are passed by position, by "
"position or keyword, or by keyword."
msgstr ""
"Varsayılan olarak, argümanlar bir Python fonksiyonuna ya pozisyona göre ya "
"da açıkça anahtar kelimeye göre aktarılabilir. Okunabilirlik ve performans "
"için, argümanların geçirilme şeklini kısıtlamak mantıklıdır, böylece bir "
"geliştiricinin öğelerin konumla mı, konumla ya da anahtar sözcükle mi yoksa "
"anahtar sözcükle mi geçirildiğini belirlemek için yalnızca fonksiyon "
"tanımına bakması gerekir."

#: tutorial/controlflow.rst:750
msgid "A function definition may look like:"
msgstr "Bir fonksiyon tanımı aşağıdaki gibi görünebilir:"

#: tutorial/controlflow.rst:752
msgid ""
"def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n"
"      -----------    ----------     ----------\n"
"        |             |                  |\n"
"        |        Positional or keyword   |\n"
"        |                                - Keyword only\n"
"         -- Positional only"
msgstr ""

#: tutorial/controlflow.rst:761
msgid ""
"where ``/`` and ``*`` are optional. If used, these symbols indicate the kind "
"of parameter by how the arguments may be passed to the function: positional-"
"only, positional-or-keyword, and keyword-only. Keyword parameters are also "
"referred to as named parameters."
msgstr ""
"burada ``/`` ve ``*`` isteğe bağlıdır. Kullanılırsa, bu semboller, "
"argümanların fonksiyona nasıl geçirilebileceğine göre parametre türünü "
"gösterir: yalnızca konumsal, konumsal veya anahtar sözcük ve yalnızca "
"anahtar sözcük. Anahtar sözcük parametreleri, adlandırılmış parametreler "
"olarak da adlandırılır."

#: tutorial/controlflow.rst:768
msgid "Positional-or-Keyword Arguments"
msgstr "Konumsal veya Anahtar Kelime Argümanları"

#: tutorial/controlflow.rst:770
msgid ""
"If ``/`` and ``*`` are not present in the function definition, arguments may "
"be passed to a function by position or by keyword."
msgstr ""
"Eğer ``/`` ve ``*`` fonksiyon tanımında mevcut değilse, argümanlar bir "
"fonksiyona pozisyon veya anahtar kelime ile aktarılabilir."

#: tutorial/controlflow.rst:775
msgid "Positional-Only Parameters"
msgstr "Yalnızca Konumsal Parametreler"

#: tutorial/controlflow.rst:777
msgid ""
"Looking at this in a bit more detail, it is possible to mark certain "
"parameters as *positional-only*. If *positional-only*, the parameters' order "
"matters, and the parameters cannot be passed by keyword. Positional-only "
"parameters are placed before a ``/`` (forward-slash). The ``/`` is used to "
"logically separate the positional-only parameters from the rest of the "
"parameters. If there is no ``/`` in the function definition, there are no "
"positional-only parameters."
msgstr ""
"Bu konuya biraz daha detaylı bakacak olursak, belirli parametreleri "
"*positional-only* olarak işaretlemek mümkündür. Eğer *konumsal-sadece* ise, "
"parametrelerin sırası önemlidir ve parametreler anahtar kelime ile "
"aktarılamaz. Yalnızca konumsal parametreler bir ``/`` (ileri eğik çizgi) "
"önüne yerleştirilir. ``/`` sadece konumsal parametreleri diğer "
"parametrelerden mantıksal olarak ayırmak için kullanılır. Fonksiyon "
"tanımında ``/`` yoksa, sadece konumsal parametre yoktur."

#: tutorial/controlflow.rst:785
msgid ""
"Parameters following the ``/`` may be *positional-or-keyword* or *keyword-"
"only*."
msgstr ""
"``/`` işaretini takip eden parametreler *konumsal veya anahtar sözcük* veya "
"*sadece anahtar sözcük* olabilir."

#: tutorial/controlflow.rst:789
msgid "Keyword-Only Arguments"
msgstr "Yalnızca Anahtar Sözcük İçeren Değişkenler"

#: tutorial/controlflow.rst:791
msgid ""
"To mark parameters as *keyword-only*, indicating the parameters must be "
"passed by keyword argument, place an ``*`` in the arguments list just before "
"the first *keyword-only* parameter."
msgstr ""
"Parametrelerin anahtar sözcük argümanıyla geçirilmesi gerektiğini belirterek "
"parametreleri *anahtar sözcüğe özel* olarak işaretlemek için, argüman "
"listesine ilk *anahtar sözcüğe özel* parametreden hemen önce bir ``*`` "
"yerleştirin."

#: tutorial/controlflow.rst:797
msgid "Function Examples"
msgstr "Fonksiyon Örnekleri"

#: tutorial/controlflow.rst:799
msgid ""
"Consider the following example function definitions paying close attention "
"to the markers ``/`` and ``*``::"
msgstr ""
"``/`` ve ``*`` işaretlerine çok dikkat ederek aşağıdaki örnek fonksiyon "
"tanımlarını göz önünde bulundurun::"

#: tutorial/controlflow.rst:802
msgid ""
">>> def standard_arg(arg):\n"
"...     print(arg)\n"
"...\n"
">>> def pos_only_arg(arg, /):\n"
"...     print(arg)\n"
"...\n"
">>> def kwd_only_arg(*, arg):\n"
"...     print(arg)\n"
"...\n"
">>> def combined_example(pos_only, /, standard, *, kwd_only):\n"
"...     print(pos_only, standard, kwd_only)"
msgstr ""

#: tutorial/controlflow.rst:815
msgid ""
"The first function definition, ``standard_arg``, the most familiar form, "
"places no restrictions on the calling convention and arguments may be passed "
"by position or keyword::"
msgstr ""
"İlk fonksiyon tanımı, ``standard_arg``, en bilinen biçimdir, çağırma "
"kuralına herhangi bir kısıtlama getirmez ve argümanlar konum veya anahtar "
"kelime ile aktarılabilir::"

#: tutorial/controlflow.rst:819
msgid ""
">>> standard_arg(2)\n"
"2\n"
"\n"
">>> standard_arg(arg=2)\n"
"2"
msgstr ""

#: tutorial/controlflow.rst:825
msgid ""
"The second function ``pos_only_arg`` is restricted to only use positional "
"parameters as there is a ``/`` in the function definition::"
msgstr ""
"İkinci fonksiyon ``pos_only_arg``, fonksiyon tanımında bir ``/`` olduğu için "
"sadece konumsal parametreleri kullanacak şekilde sınırlandırılmıştır::"

#: tutorial/controlflow.rst:828
msgid ""
">>> pos_only_arg(1)\n"
"1\n"
"\n"
">>> pos_only_arg(arg=1)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: pos_only_arg() got some positional-only arguments passed as "
"keyword arguments: 'arg'"
msgstr ""

#: tutorial/controlflow.rst:836
#, fuzzy
msgid ""
"The third function ``kwd_only_arg`` only allows keyword arguments as "
"indicated by a ``*`` in the function definition::"
msgstr ""
"Üçüncü fonksiyon ``kwd_only_args`` sadece fonksiyon tanımında ``*`` ile "
"belirtilen anahtar kelime argümanlarına izin verir::"

#: tutorial/controlflow.rst:839
msgid ""
">>> kwd_only_arg(3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n"
"\n"
">>> kwd_only_arg(arg=3)\n"
"3"
msgstr ""

#: tutorial/controlflow.rst:847
msgid ""
"And the last uses all three calling conventions in the same function "
"definition::"
msgstr "Sonuncusu ise aynı fonksiyon tanımında üç çağrı kuralını da kullanır::"

#: tutorial/controlflow.rst:850
msgid ""
">>> combined_example(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() takes 2 positional arguments but 3 were given\n"
"\n"
">>> combined_example(1, 2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(1, standard=2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(pos_only=1, standard=2, kwd_only=3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() got some positional-only arguments passed as "
"keyword arguments: 'pos_only'"
msgstr ""

#: tutorial/controlflow.rst:867
msgid ""
"Finally, consider this function definition which has a potential collision "
"between the positional argument ``name``  and ``**kwds`` which has ``name`` "
"as a key::"
msgstr ""
"Son olarak, ``name`` konumsal argümanı ile ``name`` anahtarına sahip "
"``**kwds`` arasında potansiyel bir çakışma olan bu fonksiyon tanımını "
"düşünün::"

#: tutorial/controlflow.rst:869
msgid ""
"def foo(name, **kwds):\n"
"    return 'name' in kwds"
msgstr ""

#: tutorial/controlflow.rst:872
msgid ""
"There is no possible call that will make it return ``True`` as the keyword "
"``'name'`` will always bind to the first parameter. For example::"
msgstr ""
"Anahtar kelime ``'name'`` her zaman ilk parametreye bağlanacağı için "
"``True`` döndürmesini sağlayacak olası bir çağrı yoktur. Örneğin::"

#: tutorial/controlflow.rst:875
msgid ""
">>> foo(1, **{'name': 2})\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: foo() got multiple values for argument 'name'\n"
">>>"
msgstr ""

#: tutorial/controlflow.rst:881
msgid ""
"But using ``/`` (positional only arguments), it is possible since it allows "
"``name`` as a positional argument and ``'name'`` as a key in the keyword "
"arguments::"
msgstr ""
"Ancak ``/`` (yalnızca konumsal argümanlar) kullanıldığında, ``name`` bir "
"konumsal argüman olarak ve ``'name'`` anahtar kelime argümanlarında bir "
"anahtar olarak izin verdiği için mümkündür::"

#: tutorial/controlflow.rst:883
msgid ""
">>> def foo(name, /, **kwds):\n"
"...     return 'name' in kwds\n"
"...\n"
">>> foo(1, **{'name': 2})\n"
"True"
msgstr ""

#: tutorial/controlflow.rst:889
msgid ""
"In other words, the names of positional-only parameters can be used in "
"``**kwds`` without ambiguity."
msgstr ""
"Başka bir deyişle, yalnızca konumsal parametrelerin adları ``**kwds`` içinde "
"belirsizlik olmadan kullanılabilir."

#: tutorial/controlflow.rst:894
msgid "Recap"
msgstr "Özet"

#: tutorial/controlflow.rst:896
msgid ""
"The use case will determine which parameters to use in the function "
"definition::"
msgstr ""
"Kullanım durumu, fonksiyon tanımında hangi parametrelerin kullanılacağını "
"belirleyecektir::"

#: tutorial/controlflow.rst:898
msgid "def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):"
msgstr ""

#: tutorial/controlflow.rst:900
msgid "As guidance:"
msgstr "Rehber olarak:"

#: tutorial/controlflow.rst:902
msgid ""
"Use positional-only if you want the name of the parameters to not be "
"available to the user. This is useful when parameter names have no real "
"meaning, if you want to enforce the order of the arguments when the function "
"is called or if you need to take some positional parameters and arbitrary "
"keywords."
msgstr ""
"Parametrelerin adının kullanıcı tarafından kullanılamamasını istiyorsanız "
"sadece pozisyonel seçeneğini kullanın. Bu, parametre adlarının gerçek bir "
"anlamı olmadığında, fonksiyon çağrıldığında bağımsız değişkenlerin sırasını "
"zorlamak istediğinizde veya bazı konumsal parametreler ve rastgele anahtar "
"sözcükler almanız gerektiğinde kullanışlıdır."

#: tutorial/controlflow.rst:907
msgid ""
"Use keyword-only when names have meaning and the function definition is more "
"understandable by being explicit with names or you want to prevent users "
"relying on the position of the argument being passed."
msgstr ""
"Adların bir anlamı olduğunda ve fonksiyon tanımının adlarla açık olmasıyla "
"daha anlaşılır olduğunda veya kullanıcıların geçirilen argümanın konumuna "
"güvenmesini önlemek istediğinizde yalnızca anahtar sözcük kullanın."

#: tutorial/controlflow.rst:910
msgid ""
"For an API, use positional-only to prevent breaking API changes if the "
"parameter's name is modified in the future."
msgstr ""
"Bir API için, parametrenin adı gelecekte değiştirilirse API "
"değişikliklerinin bozulmasını önlemek için yalnızca konumsal kullanın."

#: tutorial/controlflow.rst:916
msgid "Arbitrary Argument Lists"
msgstr "Keyfi Argüman Listeleri"

#: tutorial/controlflow.rst:921
msgid ""
"Finally, the least frequently used option is to specify that a function can "
"be called with an arbitrary number of arguments.  These arguments will be "
"wrapped up in a tuple (see :ref:`tut-tuples`).  Before the variable number "
"of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"Son olarak, en az kullanılan seçenek, bir fonksiyonun rastgele sayıda "
"argümanla çağrılabileceğini belirtmektir.  Bu argümanlar bir tuple içinde "
"paketlenecektir (bkz :ref:`tut-tuples`).  Değişken argüman sayısından önce, "
"sıfır veya daha fazla normal argüman olabilir. ::"

#: tutorial/controlflow.rst:926
msgid ""
"def write_multiple_items(file, separator, *args):\n"
"    file.write(separator.join(args))"
msgstr ""

#: tutorial/controlflow.rst:930
msgid ""
"Normally, these *variadic* arguments will be last in the list of formal "
"parameters, because they scoop up all remaining input arguments that are "
"passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can only "
"be used as keywords rather than positional arguments. ::"
msgstr ""
"Normalde *variadic* argümanlar biçimsel parametreler listesinde en sonda yer "
"alır, çünkü fonksiyona aktarılan geri kalan tüm girdi argümanlarını "
"toplarlar. ``*args`` parametresinden sonra gelen tüm biçimsel parametreler "
"'keyword-only' (yalnızca-anahtar-kelime) argümanlarıdır, yani konumsal "
"argümanlar yerine sadece anahtar kelimeler olarak kullanılabilirler. ::"

#: tutorial/controlflow.rst:936
msgid ""
">>> def concat(*args, sep=\"/\"):\n"
"...     return sep.join(args)\n"
"...\n"
">>> concat(\"earth\", \"mars\", \"venus\")\n"
"'earth/mars/venus'\n"
">>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n"
"'earth.mars.venus'"
msgstr ""

#: tutorial/controlflow.rst:947
msgid "Unpacking Argument Lists"
msgstr "Argüman Listelerini Açma"

#: tutorial/controlflow.rst:949
msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available "
"separately, write the function call with the  ``*``\\ -operator to unpack "
"the arguments out of a list or tuple::"
msgstr ""
"Tersi durum, argümanlar zaten bir liste veya tuple içinde olduğunda, ancak "
"ayrı konumsal argümanlar gerektiren bir fonksiyon çağrısı için paketten "
"çıkarılması gerektiğinde ortaya çıkar.  Örneğin, yerleşik :func:`range` "
"fonksiyonu ayrı *start* ve *stop* argümanları bekler.  Eğer bunlar ayrı "
"olarak mevcut değilse, argümanları bir listeden veya tuple'dan çıkarmak için "
"fonksiyon çağrısını ``*``\\ -operatörü ile yazın::"

#: tutorial/controlflow.rst:956
msgid ""
">>> list(range(3, 6))            # normal call with separate arguments\n"
"[3, 4, 5]\n"
">>> args = [3, 6]\n"
">>> list(range(*args))            # call with arguments unpacked from a "
"list\n"
"[3, 4, 5]"
msgstr ""

#: tutorial/controlflow.rst:965
msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr ""
"Aynı şekilde, sözlükler ``**``\\ -operatörü ile anahtar sözcük argümanları "
"sunabilir::"

#: tutorial/controlflow.rst:968
msgid ""
">>> def parrot(voltage, state='a stiff', action='voom'):\n"
"...     print(\"-- This parrot wouldn't\", action, end=' ')\n"
"...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n"
"...     print(\"E's\", state, \"!\")\n"
"...\n"
">>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", "
"\"action\": \"VOOM\"}\n"
">>> parrot(**d)\n"
"-- This parrot wouldn't VOOM if you put four million volts through it. E's "
"bleedin' demised !"
msgstr ""

#: tutorial/controlflow.rst:981
msgid "Lambda Expressions"
msgstr "Lambda İfadeleri"

#: tutorial/controlflow.rst:983
msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` keyword. "
"This function returns the sum of its two arguments: ``lambda a, b: a+b``. "
"Lambda functions can be used wherever function objects are required.  They "
"are syntactically restricted to a single expression.  Semantically, they are "
"just syntactic sugar for a normal function definition.  Like nested function "
"definitions, lambda functions can reference variables from the containing "
"scope::"
msgstr ""
"Küçük anonim fonksiyonlar :keyword:`lambda` anahtar sözcüğü ile "
"oluşturulabilir. Bu fonksiyon iki argümanının toplamını döndürür: ``lambda "
"a, b: a+b``. Lambda fonksiyonları, fonksiyon nesnelerinin gerekli olduğu her "
"yerde kullanılabilir.  Sözdizimsel olarak tek bir ifadeyle sınırlıdırlar.  "
"Anlamsal olarak, normal bir fonksiyon tanımı için sadece sözdizimsel "
"şekerdirler.  İç içe işlev tanımları gibi, lambda işlevleri de içeren "
"kapsamdaki değişkenlere başvurabilir::"

#: tutorial/controlflow.rst:991
msgid ""
">>> def make_incrementor(n):\n"
"...     return lambda x: x + n\n"
"...\n"
">>> f = make_incrementor(42)\n"
">>> f(0)\n"
"42\n"
">>> f(1)\n"
"43"
msgstr ""

#: tutorial/controlflow.rst:1000
msgid ""
"The above example uses a lambda expression to return a function.  Another "
"use is to pass a small function as an argument::"
msgstr ""
"Yukarıdaki örnekte bir fonksiyon döndürmek için bir lambda ifadesi "
"kullanılmıştır.  Başka bir kullanım da küçük bir fonksiyonu argüman olarak "
"geçirmektir::"

#: tutorial/controlflow.rst:1003
msgid ""
">>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n"
">>> pairs.sort(key=lambda pair: pair[1])\n"
">>> pairs\n"
"[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]"
msgstr ""

#: tutorial/controlflow.rst:1012
msgid "Documentation Strings"
msgstr "Dokümantasyon Stringler'i"

#: tutorial/controlflow.rst:1019
msgid ""
"Here are some conventions about the content and formatting of documentation "
"strings."
msgstr ""
"Belge dizelerinin içeriği ve biçimlendirilmesiyle ilgili bazı kurallar "
"aşağıda verilmiştir."

#: tutorial/controlflow.rst:1022
msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name or "
"type, since these are available by other means (except if the name happens "
"to be a verb describing a function's operation).  This line should begin "
"with a capital letter and end with a period."
msgstr ""
"İlk satır her zaman nesnenin amacının kısa ve öz bir özeti olmalıdır.  Öz "
"olması için, nesnenin adı veya türü açıkça belirtilmemelidir, çünkü bunlar "
"başka yollarla elde edilebilir (adın bir fonksiyonun çalışmasını açıklayan "
"bir fiil olması durumu hariç).  Bu satır büyük harfle başlamalı ve nokta ile "
"bitmelidir."

#: tutorial/controlflow.rst:1028
msgid ""
"If there are more lines in the documentation string, the second line should "
"be blank, visually separating the summary from the rest of the description.  "
"The following lines should be one or more paragraphs describing the object's "
"calling conventions, its side effects, etc."
msgstr ""
"Belgeleme string'inde daha fazla satır varsa, ikinci satır boş olmalı ve "
"özeti açıklamanın geri kalanından görsel olarak ayırmalıdır.  Sonraki "
"satırlar, nesnenin çağrı kurallarını, yan etkilerini vb. açıklayan bir veya "
"daha fazla paragraftan oluşmalıdır."

#: tutorial/controlflow.rst:1033
msgid ""
"The Python parser does not strip indentation from multi-line string literals "
"in Python, so tools that process documentation have to strip indentation if "
"desired.  This is done using the following convention. The first non-blank "
"line *after* the first line of the string determines the amount of "
"indentation for the entire documentation string.  (We can't use the first "
"line since it is generally adjacent to the string's opening quotes so its "
"indentation is not apparent in the string literal.)  Whitespace "
"\"equivalent\" to this indentation is then stripped from the start of all "
"lines of the string.  Lines that are indented less should not occur, but if "
"they occur all their leading whitespace should be stripped.  Equivalence of "
"whitespace should be tested after expansion of tabs (to 8 spaces, normally)."
msgstr ""
"Python ayrıştırıcısı, Python'daki çok satırlı dize değişmezlerinden "
"girintiyi çıkarmaz, bu nedenle belgeleri işleyen araçların istenirse "
"girintiyi çıkarması gerekir.  Bu, aşağıdaki kural kullanılarak yapılır. "
"Dizenin ilk satırından *sonraki* boş olmayan ilk satır, tüm dokümantasyon "
"dizesi için girinti miktarını belirler.  (İlk satırı kullanamayız, çünkü "
"genellikle dizenin açılış tırnaklarına bitişiktir, bu nedenle girintisi dize "
"değişmezinde belirgin değildir)  Bu girintiye \"eş değer\" boşluk daha sonra "
"dizenin tüm satırlarının başlangıcından çıkarılır.  Daha az girintili "
"satırlar oluşmamalıdır, ancak oluşurlarsa başlarındaki tüm boşluklar "
"çıkarılmalıdır.  Beyaz boşlukların eş değerliği sekmelerin "
"genişletilmesinden sonra test edilmelidir (normalde 8 boşluğa kadar)."

#: tutorial/controlflow.rst:1045
msgid "Here is an example of a multi-line docstring::"
msgstr "İşte çok satırlı bir docstring örneği::"

#: tutorial/controlflow.rst:1047
msgid ""
">>> def my_function():\n"
"...     \"\"\"Do nothing, but document it.\n"
"...\n"
"...     No, really, it doesn't do anything.\n"
"...     \"\"\"\n"
"...     pass\n"
"...\n"
">>> print(my_function.__doc__)\n"
"Do nothing, but document it.\n"
"\n"
"    No, really, it doesn't do anything."
msgstr ""

#: tutorial/controlflow.rst:1063
msgid "Function Annotations"
msgstr "Fonksiyon Ek Açıklamaları"

#: tutorial/controlflow.rst:1071
msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see :pep:`3107` "
"and :pep:`484` for more information)."
msgstr ""
":ref:`Fonksiyon ek açıklamaları <function>` kullanıcı tanımlı fonksiyonlar "
"tarafından kullanılan tipler hakkında tamamen isteğe bağlı meta veri "
"bilgileridir (daha fazla bilgi için :pep:`3107` ve :pep:`484` sayfalarına "
"bakınız)."

#: tutorial/controlflow.rst:1075
#, fuzzy
msgid ""
":term:`Annotations <function annotation>` are stored in the :attr:`!"
"__annotations__` attribute of the function as a dictionary and have no "
"effect on any other part of the function.  Parameter annotations are defined "
"by a colon after the parameter name, followed by an expression evaluating to "
"the value of the annotation.  Return annotations are defined by a literal ``-"
">``, followed by an expression, between the parameter list and the colon "
"denoting the end of the :keyword:`def` statement.  The following example has "
"a required argument, an optional argument, and the return value annotated::"
msgstr ""
":term:`İşaretlemeler <function annotation>`, fonksiyonun :attr:"
"`__annotations__` özelliğinde bir sözlük olarak saklanır ve fonksiyonun "
"diğer bölümleri üzerinde hiçbir etkisi yoktur.  Parametre ek açıklamaları, "
"parametre adından sonra iki nokta üst üste işareti ve ardından ek "
"açıklamanın değerine göre değerlendirilen bir ifade ile tanımlanır.  Dönüş "
"ek açıklamaları, parametre listesi ile :keyword:`def` ifadesinin sonunu "
"belirten iki nokta arasında bir ``->`` ifadesi ve ardından bir ifade ile "
"tanımlanır.  Aşağıdaki örnekte bir gerekli argüman, bir isteğe bağlı argüman "
"ve dönüş değeri ek açıklamalıdır::"

#: tutorial/controlflow.rst:1084
msgid ""
">>> def f(ham: str, eggs: str = 'eggs') -> str:\n"
"...     print(\"Annotations:\", f.__annotations__)\n"
"...     print(\"Arguments:\", ham, eggs)\n"
"...     return ham + ' and ' + eggs\n"
"...\n"
">>> f('spam')\n"
"Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class "
"'str'>}\n"
"Arguments: spam eggs\n"
"'spam and eggs'"
msgstr ""

#: tutorial/controlflow.rst:1097
msgid "Intermezzo: Coding Style"
msgstr "Intermezzo: Kodlama Stili"

#: tutorial/controlflow.rst:1102
msgid ""
"Now that you are about to write longer, more complex pieces of Python, it is "
"a good time to talk about *coding style*.  Most languages can be written (or "
"more concise, *formatted*) in different styles; some are more readable than "
"others. Making it easy for others to read your code is always a good idea, "
"and adopting a nice coding style helps tremendously for that."
msgstr ""
"Artık daha uzun, daha karmaşık Python parçaları yazmak üzere olduğunuza "
"göre, *kodlama stili* hakkında konuşmak için iyi bir zaman.  Çoğu dil farklı "
"stillerde yazılabilir (ya da daha özlü bir ifadeyle *biçimlendirilebilir*); "
"bazıları diğerlerinden daha okunaklıdır. Başkalarının kodunuzu okumasını "
"kolaylaştırmak her zaman iyi bir fikirdir ve güzel bir kodlama stili "
"benimsemek buna çok yardımcı olur."

#: tutorial/controlflow.rst:1108
msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  Every "
"Python developer should read it at some point; here are the most important "
"points extracted for you:"
msgstr ""
"Python için :pep:`8`, çoğu projenin bağlı olduğu stil kılavuzu olarak ortaya "
"çıkmıştır; okunabilir ve göze hoş gelen bir kodlama stilini teşvik eder.  "
"Her Python geliştiricisi bir noktada onu okumalıdır; işte sizin için "
"çıkarılan en önemli noktalar:"

#: tutorial/controlflow.rst:1113
msgid "Use 4-space indentation, and no tabs."
msgstr "4 aralıklı girinti kullanın ve sekme kullanmayın."

#: tutorial/controlflow.rst:1115
msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"4 boşluk, küçük girinti (daha fazla iç içe geçme derinliği sağlar) ve büyük "
"girinti (okunması daha kolay) arasında iyi bir uzlaşmadır.  Sekmeler "
"karışıklığa neden olur ve en iyisi dışarıda bırakmaktır."

#: tutorial/controlflow.rst:1119
msgid "Wrap lines so that they don't exceed 79 characters."
msgstr "Satırları 79 karakteri geçmeyecek şekilde sarın."

#: tutorial/controlflow.rst:1121
msgid ""
"This helps users with small displays and makes it possible to have several "
"code files side-by-side on larger displays."
msgstr ""
"Bu, küçük ekranlı kullanıcılara yardımcı olur ve daha büyük ekranlarda "
"birkaç kod dosyasının yan yana olmasını mümkün kılar."

#: tutorial/controlflow.rst:1124
msgid ""
"Use blank lines to separate functions and classes, and larger blocks of code "
"inside functions."
msgstr ""
"Fonksiyonları ve sınıfları ve fonksiyonların içindeki büyük kod bloklarını "
"ayırmak için boş satırlar kullanın."

#: tutorial/controlflow.rst:1127
msgid "When possible, put comments on a line of their own."
msgstr "Mümkün olduğunda, yorumları kendi başlarına bir satıra koyun."

#: tutorial/controlflow.rst:1129
msgid "Use docstrings."
msgstr "Docstrings kullanın."

#: tutorial/controlflow.rst:1131
msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr ""
"Operatörlerin etrafında ve virgüllerden sonra boşluk kullanın, ancak "
"doğrudan parantez yapılarının içinde kullanmayın: ``a = f(1, 2) + g(3, 4)``."

#: tutorial/controlflow.rst:1134
msgid ""
"Name your classes and functions consistently; the convention is to use "
"``UpperCamelCase`` for classes and ``lowercase_with_underscores`` for "
"functions and methods.  Always use ``self`` as the name for the first method "
"argument (see :ref:`tut-firstclasses` for more on classes and methods)."
msgstr ""
"Sınıflarınızı ve fonksiyonlarınızı tutarlı bir şekilde adlandırın; buradaki "
"kural, sınıflar için ``UpperCamelCase``, fonksiyonlarını; metotlar için de "
"``lowercase_with_underscores`` kullanmaktır.  İlk yöntem argümanının adı "
"olarak her zaman ``self`` kullanın (sınıflar ve yöntemler hakkında daha "
"fazla bilgi için :ref:`tut-firstclasses` bölümüne bakın)."

#: tutorial/controlflow.rst:1139
msgid ""
"Don't use fancy encodings if your code is meant to be used in international "
"environments.  Python's default, UTF-8, or even plain ASCII work best in any "
"case."
msgstr ""
"Kodunuz uluslararası ortamlarda kullanılacaksa süslü kodlamalar "
"kullanmayın.  Python'un varsayılanı, UTF-8 veya hatta düz ASCII her durumda "
"en iyi sonucu verir."

#: tutorial/controlflow.rst:1143
msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only the "
"slightest chance people speaking a different language will read or maintain "
"the code."
msgstr ""
"Aynı şekilde, farklı bir dil konuşan kişilerin kodu okuması veya muhafaza "
"etmesi için en ufak bir şans varsa, tanımlayıcılarda ASCII olmayan "
"karakterler kullanmayın."

#: tutorial/controlflow.rst:1149
msgid "Footnotes"
msgstr "Dipnotlar"

#: tutorial/controlflow.rst:1150
msgid ""
"Actually, *call by object reference* would be a better description, since if "
"a mutable object is passed, the caller will see any changes the callee makes "
"to it (items inserted into a list)."
msgstr ""
"Aslında, *nesne referansı ile çağırma* daha iyi bir tanımlama olacaktır, "
"çünkü değiştirilebilir bir nesne aktarılırsa, çağıran, çağırılanın üzerinde "
"yaptığı tüm değişiklikleri (bir listeye eklenen öğeler) görecektir."

#: tutorial/controlflow.rst:48
msgid "statement"
msgstr ""

#: tutorial/controlflow.rst:48
msgid "for"
msgstr ""

#: tutorial/controlflow.rst:1014
#, fuzzy
msgid "documentation strings"
msgstr "Dokümantasyon Stringler'i"

#: tutorial/controlflow.rst:1014
#, fuzzy
msgid "docstrings"
msgstr "Docstrings kullanın."

#: tutorial/controlflow.rst:1014
msgid "strings, documentation"
msgstr ""

#: tutorial/controlflow.rst:918
msgid "* (asterisk)"
msgstr ""

#: tutorial/controlflow.rst:962
#, fuzzy
msgid "in function calls"
msgstr "Fonksiyon Örnekleri"

#: tutorial/controlflow.rst:962
msgid "**"
msgstr ""

#: tutorial/controlflow.rst:1066
#, fuzzy
msgid "function"
msgstr "Fonksiyonların Tanımlanması"

#: tutorial/controlflow.rst:1066
#, fuzzy
msgid "annotations"
msgstr "Fonksiyon Ek Açıklamaları"

#: tutorial/controlflow.rst:1066
msgid "->"
msgstr ""

#: tutorial/controlflow.rst:1066
#, fuzzy
msgid "function annotations"
msgstr "Fonksiyon Ek Açıklamaları"

#: tutorial/controlflow.rst:1066
msgid ": (colon)"
msgstr ""

#: tutorial/controlflow.rst:1100
msgid "coding"
msgstr ""

#: tutorial/controlflow.rst:1100
msgid "style"
msgstr ""

#, fuzzy
#~ msgid ""
#~ "A :keyword:`!for` or :keyword:`!while` loop can include an :keyword:`!"
#~ "else` clause."
#~ msgstr ""
#~ ":keyword:`!break` ve :keyword:`!continue` İfadeleri ve :keyword:`!else` "
#~ "Döngülerdeki Cümleler"

#~ msgid ""
#~ "Loop statements may have an :keyword:`!else` clause; it is executed when "
#~ "the loop terminates through exhaustion of the iterable (with :keyword:"
#~ "`for`) or when the condition becomes false (with :keyword:`while`), but "
#~ "not when the loop is terminated by a :keyword:`break` statement.  This is "
#~ "exemplified by the following loop, which searches for prime numbers::"
#~ msgstr ""
#~ "Döngü deyimleri bir :keyword:`!else` cümlesine sahip olabilir; bu cümle "
#~ "döngü yinelenebilirin tükenmesiyle sonlandığında (:keyword:`for` ile) "
#~ "veya koşul yanlış olduğunda (:keyword:`while` ile) çalıştırılır, ancak "
#~ "döngü bir :keyword:`break` deyimiyle sonlandırıldığında çalıştırılmaz.  "
#~ "Bu, asal sayıları arayan aşağıdaki döngü ile örneklendirilmiştir::"
